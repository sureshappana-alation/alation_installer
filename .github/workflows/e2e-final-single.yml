name: unified-installer-final-single-job

on:
  push:
    branches: [main]

  workflow_dispatch:
    inputs:
      ALATION_ANALYTICS:
        description: 'Alation analytics version'
        required: false
      OCF:
        description: 'OCF version'
        required: false
      KURL:
        description: 'KURL Version'
        required: false

env:
  S3_DEV_BUCKET_URL: "s3://${{ secrets.S3_DEV_BUCKET_NAME }}"
  S3_RELEASE_BUCKET_URL: "s3://${{ secrets.S3_RELEASE_BUCKET_NAME }}"
  BASE_DIR: ./alation
  RESOURCE_DIR: ./alation/res
  MODULES_DIR: ./alation/res/modules
  KURL_PATCH_DIR: ./alation/res/kurl_patch
  ALATION_BUILD_OUTPUT: alation-$GITHUB_RUN_NUMBER.tar.gz
  ALATION_OUTPUT: alation-$GITHUB_RUN_NUMBER.tar.gz

jobs:

  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    
    - name: Setup golang
      uses: actions/setup-go@v2
    
    - name: Copy go artifacts
      run: |
        cp ${{ github.workspace }}installer/go.sum ${{ github.workspace }}installer/src/go.sum
        cp ${{ github.workspace }}installer/go.mod ${{ github.workspace }}installer/src/go.mod
    
    - name: Build installer
      run: go build -o ${{ env.BASE_DIR }}/installer ${{ github.workspace }}installer/*.go
    
    - name: List of files
      run: find ${{ env.BASE_DIR }}

    - name: Upload installer binary for app-setup job
      uses: actions/upload-artifact@v2
      with:
        name: installer-binary
        path: ${{ env.BASE_DIR }}
        retention-days: 1
  # build:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v1

  #     - name: Checkout code
  #       uses: actions/checkout@v2

  #     - name: Create output directory
  #       run: |
  #         mkdir -p ${{ env.BASE_DIR }}
      
  #     - name: Build installer binary
  #       id: docker_build
  #       uses: docker/build-push-action@v2
  #       with:
  #         context: ./installer
  #         push: false
  #         tags: alation/installer:latest
  #         outputs: type=local,dest=.
  #         cache-from: |
  #           user/app:cache
  #           type=local,src=./docker-cache
      
  #     - name: Extract the generated installer tar file
  #       run: tar xvzf installer.tar.gz
      
  #     - name: Copying the installer binary to base directory
  #       run: mv installer/installer ${{ env.BASE_DIR }}/
      
  #     - name: Image digest
  #       run: echo ${{ steps.docker_build.outputs.digest }}

  #     - name: List of files
  #       run: find ${{ env.BASE_DIR }}

  #     - name: Upload installer binary for package job
  #       uses: actions/upload-artifact@v2
  #       with:
  #         name: docker-artifact
  #         path: ${{ env.BASE_DIR }}
  #         retention-days: 1

  app-setup:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
              
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_S3_REGION }}
      
      - name: Download installer from build job
        uses: actions/download-artifact@v2
        with:
          name: installer-binary
          path: ${{ env.BASE_DIR }}
      
      - name: Read environment versions files
        id: read_env
        run: |
          applicationList=()
          for i in ./versions/*.sh; do
            while read line || [ -n "$line" ];
            do
                set -f; IFS="="; application=($line)
                if [[ "${application[0],,}" != *"kurl"* ]];then
                  applicationList+=(${application[0]})
                fi
            done < "${i}"
            cat "$i"
            echo
          done  >> $GITHUB_ENV
          # echo APPLICATION_LIST=${applicationList[@]} >> $GITHUB_ENV
          echo ::set-output name=applicationList::${applicationList[@]}

      - name: Creating required directories
        run: |
          mkdir -p ${{ env.BASE_DIR }}
          mkdir -p ${{ env.MODULES_DIR }}
          mkdir -p ${{ env.KURL_PATCH_DIR }}

      - name: Copy res content from source code to archiving directory
        run: |
          cp -a ${{ github.workspace }}/installer/res/. ${{ env.BASE_DIR }}/res/
      
      - name: Set environment variables
        run: |
          echo KURL_FILE_NAME=kurl-${{ env.KURL }}.tar.gz >> $GITHUB_ENV
      
      - name: Importing kurl package from cache
        id: kurl-cache
        uses: actions/cache@v2
        with:
          path: ./dependencies
          key: ${{ env.KURL_FILE_NAME }}

      - name: In case of cache miss get the Kurl package from S3 or Kurl.sh
        if: steps.kurl-cache.outputs.cache-hit != 'true'
        run: |
          echo "Checking if kurl package ${{env.KURL_FILE_NAME}} exists in S3"
          mkdir -p ./dependencies
          exists=$(aws s3api list-objects-v2 --bucket ${{ secrets.S3_DEV_BUCKET_NAME }} --query "contains(Contents[].Key, '${{ env.KURL_FILE_NAME }}')" || false)
          if $exists; then
            echo "Kurl package ${{env.KURL_FILE_NAME}} exists in S3. Downloading..."
            aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/${{env.KURL_FILE_NAME}} ./dependencies/${{ env.KURL_FILE_NAME }}            
          else
            echo "Kurl package ${{ env.KURL_FILE_NAME }} does not exists in S3. Fetching it from Kurl.sh repo..."
            curl -LO https://k8s.kurl.sh/bundle/${{ env.KURL }}
            mv ${{ env.KURL }} ./dependencies/${{env.KURL_FILE_NAME}}
            echo "Uploading Kurl Package ${{ env.BASE_DIR}}/${{ env.KURL_FILE_NAME }} to S3"
            aws s3 cp ./dependencies/${{ env.KURL_FILE_NAME }} ${{ env.S3_DEV_BUCKET_URL }}/${{ env.KURL_FILE_NAME }}
          fi
      - name: Copy Kurl file from dependencies to the installer base directory
        run: |
          cp ./dependencies/${{env.KURL_FILE_NAME}} ${{ env.RESOURCE_DIR}}/${{env.KURL_FILE_NAME}} 
      # - name: Check if Kurl Package exists in S3
      #   if: steps.kurl-cache.outputs.cache-hit != 'true'
      #   run: |
      #     echo "Checking if kurl package ${{env.KURL_FILE_NAME}} exists in S3"
      #     exists=$(aws s3api list-objects-v2 --bucket ${{ secrets.S3_DEV_BUCKET_NAME }} --query "contains(Contents[].Key, '${{ env.KURL_FILE_NAME }}')" || false)
      #     if $exists; then
      #       echo "Kurl package ${{env.KURL_FILE_NAME}} exists in S3. Downloading..."
      #       aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/${{env.KURL_FILE_NAME}} ${{ env.RESOURCE_DIR }}/${{ env.KURL_FILE_NAME }}            
      #     else
      #       echo "Kurl package ${{ env.KURL_FILE_NAME }} does not exists in S3. Fetching it from Kurl.sh repo..."
      #       curl -LO https://k8s.kurl.sh/bundle/${{ env.KURL }}
      #       mv ${{ env.KURL }} ${{ env.BASE_DIR }}/${{env.KURL_FILE_NAME}}
      #       echo "Uploading Kurl Package ${{ env.BASE_DIR}}/${{ env.KURL_FILE_NAME }} to S3"
      #       aws s3 cp ${{ env.BASE_DIR }}/${{ env.KURL_FILE_NAME }} ${{ env.S3_DEV_BUCKET_URL }}/${{ env.KURL_FILE_NAME }}
      #     fi
      

      - name: Download files from S3
        run: |
          for i in ${{ steps.read_env.outputs.applicationList }}; do
            applicationName="${i,,}"
            application="${applicationName}-${!i}.tar.gz"
            echo "Downloading $application from S3"
            aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/$application ${{env.MODULES_DIR}}/$applicationName/
          done

      - name: Generate alation-install.yaml file
        run: |
          installConfigFile=${{ env.BASE_DIR }}/alation-install.yaml
          touch $installConfigFile
          for dir in $(find $MODULES_DIR -mindepth 1 -maxdepth 1 -type d); do
            directory=${dir%*/}
            echo "Processing $directory"
            files=$(find $directory -mindepth 1 -maxdepth 1 -iname "*.tar.gz")
            if [ "${#files}" -gt 1 ]; then
                moduleFile=${files[0]}
                echo "Found $moduleFile. Extracting..."
                tar -xzf $moduleFile -C $directory  --strip-components=2
                if test -f "$directory/install.yaml"; then
                  echo "Found $directory/install.yaml"
                  echo "Appending $directory/install.yaml content to $installConfigFile file"
                  echo "${directory##*/}:" >> $installConfigFile
                  sed -e 's/^/  /' $directory/install.yaml >> $installConfigFile
                else
                  echo "$directory/install.yaml" doesn\'t exists. Ignoring...
                fi
                echo "Deleting $moduleFile"
                rm -f $moduleFile
            else
              echo "No tar files found in $directory"
            fi
          done

      - name: print list of files
        run: find ${{ env.BASE_DIR }}

      - name: Compress the final bundle
        run: tar -cvzf ${{ env.ALATION_OUTPUT }} ./alation

      - name: Upload the compressd build to S3
        run: |
          aws s3 cp ${{ env.ALATION_OUTPUT }} ${{ env.S3_RELEASE_BUCKET_URL }}/${{ env.ALATION_OUTPUT }}
