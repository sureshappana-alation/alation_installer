name: unified-installer-build-pipeline-final

on:
  # Run the job when pull request closed
  # This job will only run if the PR has been merged.
  # This is commented for now to trigger the job manually only
  # pull_request:
  #   types: [ closed ]

  # This section is to trigger the workflow manually
  workflow_dispatch:
    inputs:
      KURL:
        description: 'KURL version'
        required: false
      ALATIONANALYTICS:
        description: 'Alation Analytics version'
        required: false

env:
  S3_DEV_BUCKET_URL: "s3://${{ secrets.S3_DEV_BUCKET_NAME }}"
  S3_RELEASE_BUCKET_URL: "s3://${{ secrets.S3_RELEASE_BUCKET_NAME }}"
  BASE_DIR: ./alation
  RESOURCE_DIR: ./alation/res
  MODULES_DIR: ./alation/res/modules
  KURL_PATCH_DIR: ./alation/res/kurl_patch
  ALATION_OUTPUT_DIR: alation-$GITHUB_RUN_NUMBER
  ALATION_OUTPUT: alation-$GITHUB_RUN_NUMBER.tar.gz
  VERSIONS_FILE: ./alation/versions.txt
  INSTALL_CONFIG_FILE: ./alation/alation_install.yaml

jobs:
  # Build job builds the installer go module which generates and exports go binary
  build:
    # This job will only run if the PR has been merged.
    # This is commented for now to trigger the job manually only
    # if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:

    - name: Checkout code
      uses: actions/checkout@v2
    
    - name: Setup golang
      uses: actions/setup-go@v2
      with:
        go-version: 1.16.4
    
    - name: Copy go artifacts to respective directories
      run: |
        cd ${{ github.workspace }}/installer
        cp go.sum src/go.sum
        cp go.mod src/go.mod
    
    - name: Build installer
      run: |
        cd ${{ github.workspace }}/installer/src
        go build -o out/installer *.go
    
    - name: List of files in the out directory
      run: find ${{ github.workspace }}/installer/src/out

    - name: Upload installer binary for app-setup job
      uses: actions/upload-artifact@v2
      with:
        name: installer-binary
        path: ${{ github.workspace }}/installer/src/out
        retention-days: 1

  # This job is for creating alation unified installer build
  app-setup:
    runs-on: ubuntu-latest
    # This job will only run if the PR has been merged.
    # This is commented for now to trigger the job manually only
    # if: github.event.pull_request.merged == true
    needs: build
    env:
      INPUT_KURL: ${{ github.event.inputs.KURL }}
      INPUT_ALATIONANALYTICS: ${{ github.event.inputs.ALATIONANALYTICS }}

    steps:   
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_S3_REGION }}

      - name: Checkout code
        uses: actions/checkout@v2

      # - name: Apply execute permissions for files
      #   run: |
      #     chmod +x "${GITHUB_WORKSPACE}/.github/scripts/*.sh"

      - name: Creating required directories
        run: |
          mkdir -p ${{ env.BASE_DIR }}
          mkdir -p ${{ env.MODULES_DIR }}
          mkdir -p ${{ env.KURL_PATCH_DIR }}

      - name: Copy res content from source code to archiving directory
        run: |
          cp -a ${{ github.workspace }}/installer/res/. ${{ env.BASE_DIR }}/res/

      - name: Read environment versions files
        id: read_env
        run: |
          modulesList=()
          shopt -s nullglob
          for file in ./versions/*.env; do
            while IFS='=' read -r key val
            do
              # Ignore KURL from modules list as KURL has special treatment
              if [[ $key != *"KURL"* ]]; then
                modulesList+=($key)
              fi
            done < "$file"
            cat "$file"
            echo
          done  >> $GITHUB_ENV
          echo ::set-output name=modulesList::${modulesList[@]}
      
      - name: Print modules list
        run: |
          echo ${{ steps.read_env.outputs.modulesList }}

      # This section overrides the user inputs provided manually in UI or REST
      - name: Apply overrides from user inputs and set as env variables
        run: |
          for app in ${{ steps.read_env.outputs.modulesList }}; do
            input_key="input_$app"
            echo "$app=${!input_key:-${!app}}" >> $GITHUB_ENV
          done
          echo KURL=${INPUT_KURL:-$KURL} >> $GITHUB_ENV
          echo KURL_FILE_NAME=kurl-$KURL.tar.gz >> $GITHUB_ENV

          echo "Adding Kurl version to versions file"
          echo "KURL= ${{ env.KURL }}" >> ${{ env.VERSIONS_FILE }}

          # Exit when KURL Version is not available
          if [[ -z $KURL ]]; then
            echo "Existing workflow run as KURL version is not set"
            exit 1
          fi
      
      # Caching Kurl package
      - name: Importing kurl package from cache
        id: kurl-cache
        uses: actions/cache@v2
        with:
          path: ${{ env.RESOURCE_DIR }}/kurl.tar.gz
          key: ${{ env.KURL_FILE_NAME }}

      - name: Create versions and install config file
        run: |
          touch ${{ env.VERSIONS_FILE }} ${{ env.INSTALL_CONFIG_FILE }}

      - name: In the case of cache miss get the Kurl package from S3
        if: steps.kurl-cache.outputs.cache-hit != 'true'
        run: |
          echo "Downloading Kurl package ${{env.KURL_FILE_NAME}} from S3. "
          aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/${{ env.KURL_FILE_NAME }} ${{ env.RESOURCE_DIR }}/kurl.tar.gz

      - name: Download modules from S3
        run: |
          for i in ${{ steps.read_env.outputs.modulesList }}; do
            module="${i}"
            
            # Add entry to versions file
            echo "$module=${!module}" >> ${{ env.VERSIONS_FILE }}

            # Download files from S3 only if version is not null and skip
            if [[ ${!module} = "skip" ]] || [[ -z ${!module} ]]; then
              echo "Skipping $module"
            else
              moduleFullName="${module}-${!i}.tar.gz"
              echo "Downloading $moduleFullName from S3"
              aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/${moduleFullName,,} ${{env.MODULES_DIR}}/${module,,}/
            fi
          done

      - name: Generate alation-install.yaml file content
        run: ${{ github.workspace }}/.github/scripts/generate-alation-install.sh

      - name: Download installer binary from build job
        uses: actions/download-artifact@v2
        with:
          name: installer-binary
          path: ${{ env.BASE_DIR }}

      - name: Print list of files
        run: find ${{ env.BASE_DIR }}

      - name: Print list of versions information
        run: cat ${{ env.VERSIONS_FILE }}

      - name: Renaming base directory to alation version
        run: mv ./alation ${{ env.ALATION_OUTPUT_DIR }}

      - name: Compress the final bundle
        run: tar -cvzf ${{ env.ALATION_OUTPUT }} ${{ env.ALATION_OUTPUT_DIR }}

      - name: Renaming alation version directory back to original for caching
        run: mv ${{ env.ALATION_OUTPUT_DIR }} ./alation

      - name: Upload the compressed build to S3
        run: |
          aws s3 cp ${{ env.ALATION_OUTPUT }} ${{ env.S3_RELEASE_BUCKET_URL }}/${{ env.ALATION_OUTPUT }}
