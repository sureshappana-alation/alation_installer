name: unified-installer-build-pipeline-final

on:
  # pull_request:
  #   types: [ closed ] # Run the job when pull request closed

  # This section is to trigger the workflow manually
  workflow_dispatch:
    inputs:
      KURL:
        description: 'KURL version'
        required: false
      ALATIONANALYTICS:
        description: 'Alation Analytics version'
        required: false

env:
  S3_DEV_BUCKET_URL: "s3://${{ secrets.S3_DEV_BUCKET_NAME }}"
  S3_RELEASE_BUCKET_URL: "s3://${{ secrets.S3_RELEASE_BUCKET_NAME }}"
  BASE_DIR: ./alation
  RESOURCE_DIR: ./alation/res
  MODULES_DIR: ./alation/res/modules
  KURL_PATCH_DIR: ./alation/res/kurl_patch
  ALATION_OUTPUT_DIR: alation-$GITHUB_RUN_NUMBER
  ALATION_OUTPUT: alation-$GITHUB_RUN_NUMBER.tar.gz
  VERSIONS_FILE: ./alation/versions.txt
  INSTALL_CONFIG_FILE: ./alation/alation_install.yaml

jobs:
  # Build job builds the installer go application which generates and exports go binary
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Checkout code
      uses: actions/checkout@v2
    
    - name: Setup golang
      uses: actions/setup-go@v2
      with:
        go-version: 1.16.4
    
    - name: Copy go artifacts to respective directories
      run: |
        cd ${{ github.workspace }}/installer
        cp go.sum src/go.sum
        cp go.mod src/go.mod
    
    - name: Build installer
      run: |
        cd ${{ github.workspace }}/installer/src
        go build -o out/installer *.go
    
    - name: List of files in the out directory
      run: find ${{ github.workspace }}/installer/src/out

    - name: Upload installer binary for app-setup job
      uses: actions/upload-artifact@v2
      with:
        name: installer-binary
        path: ${{ github.workspace }}/installer/src/out
        retention-days: 1

  # This job is for creating alation unified installer build
  app-setup:
    runs-on: ubuntu-latest
    needs: build
    env:
      INPUT_KURL: ${{ github.event.inputs.KURL }}
      INPUT_ALATIONANALYTICS: ${{ github.event.inputs.ALATIONANALYTICS }}

    steps:   
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_S3_REGION }}

      - name: Checkout code
        uses: actions/checkout@v2

      - name: Creating required directories
        run: |
          mkdir -p ${{ env.BASE_DIR }}
          mkdir -p ${{ env.MODULES_DIR }}
          mkdir -p ${{ env.KURL_PATCH_DIR }}

      - name: Copy res content from source code to archiving directory
        run: |
          cp -a ${{ github.workspace }}/installer/res/. ${{ env.BASE_DIR }}/res/

      - name: Read environment versions files
        id: read_env
        run: |
          applicationList=()
          shopt -s nullglob
          for i in ./versions/*.env; do
            while IFS='=' read -r key val
            do
              if [[ $key != *"kurl"* ]]; then
                applicationList+=(${key})
              fi
            done < "${i}"
            cat "${i}"
            echo
          done  >> $GITHUB_ENV
          echo ::set-output name=applicationList::${applicationList[@]}
      
      - name: Print application list
        run: |
          echo ${{ steps.read_env.outputs.applicationList }}

      # This section overrides the user inputs provided manually or REST
      - name: Apply overrides from user inputs and set as env variables
        run: |
          for app in ${{ steps.read_env.outputs.applicationList }}; do
            input_key="input_$app"
            echo "$app=${!input_key:-${!app}}" >> $GITHUB_ENV
          done
          echo KURL=${INPUT_KURL:-$KURL} >> $GITHUB_ENV
          echo KURL_FILE_NAME=kurl-${{ env.kurl }}.tar.gz >> $GITHUB_ENV
      
      # Caching Kurl package
      - name: Importing kurl package from cache
        id: kurl-cache
        uses: actions/cache@v2
        with:
          path: ${{ env.RESOURCE_DIR }}/kurl.tar.gz
          key: ${{ env.KURL_FILE_NAME }}

      - name: Create versions and install config file
        run: |
          touch {{ env.VERSIONS_FILE }} {{ env.INSTALL_CONFIG_FILE }}

      - name: In the case of cache miss get the Kurl package from S3
        if: steps.kurl-cache.outputs.cache-hit != 'true'
        run: |
          echo "Adding Kurl version to versions file"
          echo "KURL= {{ env.KURL }}" >> {{ env.VERSIONS_FILE }}
          echo "Downloading Kurl package ${{env.KURL_FILE_NAME}} from S3. "
          aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/${{ env.KURL_FILE_NAME }} ${{ env.RESOURCE_DIR }}/kurl.tar.gz

      - name: Download application files from S3
        run: |
          for i in ${{ steps.read_env.outputs.applicationList }}; do
            applicationName="${i}"
            
            # Add entry to versions file
            echo "$applicationName=${!applicationName}"" >> {{ env.VERSIONS_FILE }}

            # Download files from S3 only if version is not null and skip
            if [[ ${!applicationName} = "skip" ]] || [[ -z ${!applicationName} ]]; then
              echo "Skipping $applicationName"
            else
              application="${applicationName}-${!i}.tar.gz"
              echo "Downloading $application from S3"
              aws s3 cp ${{ env.S3_DEV_BUCKET_URL }}/$application ${{env.MODULES_DIR}}/$applicationName/
            fi
          done

      - name: Generate alation-install.yaml file content
        run: |
          for dir in $(find $MODULES_DIR -mindepth 1 -maxdepth 1 -type d); do
            directory=${dir%*/}

            echo "[$directory]: Started processing"
            files=$(find $directory -mindepth 1 -maxdepth 1 -iname "*.tar.gz")
            
            # 
            if [ "${#files}" -gt 1 ]; then
                moduleFile=${files[0]}
                echo "[$directory]: Found $moduleFile. Extracting..."
                tar -xzf $moduleFile -C $directory  --strip-components=1
                echo "Deleting $moduleFile"
                rm -f $moduleFile
            else
              echo "[$directory]: No module tar files found"
            fi
            
            if test -f "$directory/install.yaml"; then
              echo "[$directory]: Found install.yaml"
              echo "[$directory]: Appending install.yaml content to {{ env.INSTALL_CONFIG_FILE }} file"
              
              # Creating any entry for module in alation_install.yaml
              echo "${directory##*/}:" >> {{ env.INSTALL_CONFIG_FILE }}
              
              # Adding contents of install.yaml to alation_install.yaml with indentation
              sed -e 's/^/  /' $directory/install.yaml >> {{ env.INSTALL_CONFIG_FILE }}
            else
              echo "$directory/install.yaml" doesn\'t exists. Ignoring...
            fi
          done

      - name: Download installer binary from build job
        uses: actions/download-artifact@v2
        with:
          name: installer-binary
          path: ${{ env.BASE_DIR }}

      - name: Print list of files
        run: find ${{ env.BASE_DIR }}

      - name: Renaming base directory to alation version
        run: mv ./alation ${{ env.ALATION_OUTPUT_DIR }}

      - name: Compress the final bundle
        run: tar -cvzf ${{ env.ALATION_OUTPUT }} ${{ env.ALATION_OUTPUT_DIR }}

      - name: Renaming alation version directory back to original for caching
        run: mv ${{ env.ALATION_OUTPUT_DIR }} ./alation 

      - name: Upload the compressed build to S3
        run: |
          aws s3 cp ${{ env.ALATION_OUTPUT }} ${{ env.S3_RELEASE_BUCKET_URL }}/${{ env.ALATION_OUTPUT }}
